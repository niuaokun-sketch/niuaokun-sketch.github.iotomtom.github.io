<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>ECO-MONITOR | 最终版</title>
    <style>
        /* --- 1. 基础样式 --- */
        body { 
            margin: 0; overflow: hidden; 
            background-color: #ffffff; 
            cursor: none; /* 隐藏系统鼠标，完全依靠 3D 光标 */ 
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        /* --- 2. 资料面板 (保持清新风格) --- */
        #data-panel {
            position: absolute; right: 40px; top: 50%; transform: translateY(-50%);
            width: 280px; padding: 30px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-left: 5px solid #333;
            color: #333;
            display: none; 
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            z-index: 10;
        }
        h2 { margin: 0 0 15px 0; font-size: 24px; letter-spacing: -1px; }
        .tag { 
            display: inline-block; background: #eee; 
            padding: 4px 8px; font-size: 10px; border-radius: 4px; 
            margin-bottom: 20px; font-weight: bold; color: #666;
        }
        .stat-item { margin-bottom: 10px; font-size: 12px; }
        .bar-bg { width: 100%; height: 6px; background: #eee; border-radius: 3px; overflow: hidden; margin-top: 4px;}
        .bar-fill { height: 100%; background: #333; width: 0%; border-radius: 3px; }

        /* --- 3. 顶部 UI --- */
        #ui-header {
            position: absolute; top: 30px; left: 40px; color: #333;
            pointer-events: none; z-index: 10;
        }
        h1 { margin: 0; font-size: 18px; font-weight: 700; letter-spacing: 1px; }
        p { margin: 5px 0 0 0; font-size: 12px; color: #999; }
    </style>
</head>
<body>

    <!-- UI -->
    <div id="ui-header">
        <h1>ECO-MONITOR</h1>
        <p>Live Bio-Data // Sector 7</p>
    </div>

    <!-- 资料面板 -->
    <div id="data-panel">
        <span class="tag" id="panel-id">ID: 001</span>
        <h2 id="panel-name">Target Name</h2>
        <div class="stat-item">TOXICITY<div class="bar-bg"><div class="bar-fill" id="bar-tox" style="background: #ff4444;"></div></div></div>
        <div class="stat-item">ADAPTATION<div class="bar-bg"><div class="bar-fill" id="bar-adp" style="background: #44cc88;"></div></div></div>
        <p style="font-size:12px; line-height:1.6; color:#666; margin-top:20px;" id="panel-desc">...</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Shader 保持不变 (微小避让) -->
    <script type="x-shader/x-vertex" id="vertexShader">
        uniform float uTime;
        uniform vec3 uMouse;
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main() {
            vColor = customColor;
            vec3 pos = position;
            float dist = distance(pos.xz, uMouse.xz);
            float radius = 7.0; 
            if (dist < radius) {
                vec3 dir = normalize(pos - uMouse);
                float force = (radius - dist) / radius;
                pos.x += dir.x * force * 3.0; 
                pos.z += dir.z * force * 3.0;
            }
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (200.0 / -mvPosition.z); 
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        varying vec3 vColor;
        void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
            if (alpha < 0.01) discard;
            gl_FragColor = vec4(vColor, alpha); 
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. 场景 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        scene.fog = new THREE.FogExp2(0xffffff, 0.012);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 70);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        // --- 2. 3D 光标系统 (Mesh Cursor) ---
        const cursorGroup = new THREE.Group();
        scene.add(cursorGroup);

        // A. 六边形环 (加粗)
        // RingGeometry(内径, 外径, 边数) -> 边数=6 就是六边形
        const hexGeometry = new THREE.RingGeometry(2.5, 3.2, 6); 
        const hexMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
        const cursorHex = new THREE.Mesh(hexGeometry, hexMaterial);
        cursorHex.rotation.x = -Math.PI / 2; // 躺平
        cursorGroup.add(cursorHex);

        // B. 倒三角形指针 (Suspended Marker)
        const triGeometry = new THREE.ConeGeometry(0.5, 1.5, 3); // 3边锥体就是三角
        const triMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const cursorTri = new THREE.Mesh(triGeometry, triMaterial);
        cursorTri.rotation.x = Math.PI; // 尖朝下
        cursorTri.position.y = 4; // 悬浮在圆环上方
        cursorGroup.add(cursorTri);

        // --- 3. 射线交互平面 ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const hitPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(500, 500),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        hitPlane.rotation.x = -Math.PI / 2;
        scene.add(hitPlane);

        // --- 4. 地形系统 (保持你的参数) ---
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];

        const colWater = new THREE.Color("#99DDFF");
        const colLand1 = new THREE.Color("#88CC44"); 
        const colLand2 = new THREE.Color("#66AA33"); 
        const colLand3 = new THREE.Color("#DDEEAA"); 

        const range = 180; const gap = 2.5; 

        // 提取高度函数供光标使用
        function getElevation(x, z) {
            return Math.sin(x * 0.05) * 8 + Math.cos(z * 0.05) * 8;
        }

        for (let x = -range; x < range; x += gap) {
            for (let z = -range; z < range; z += gap) {
                const distToCenter = Math.sqrt(x*x + z*z);
                const maxRadius = 120 + Math.sin(Math.atan2(z, x) * 5.0) * 15.0 + Math.cos(x * 0.1) * 10.0;
                if (distToCenter > maxRadius) continue;

                let y = getElevation(x, z);
                
                let pSize = 0.0; let pColor = new THREE.Color(); let keepPoint = false;
                if (y < -3) {
                    if (Math.random() > 0.4) { pSize = 4.0; pColor = colWater; keepPoint = true; }
                } else {
                    if (Math.random() > 0.5) { 
                        keepPoint = true;
                        const r = Math.random();
                        if (r > 0.95) { pSize = 5.0; pColor = colLand1; }
                        else if (r > 0.6) { pSize = 2.5; pColor = colLand2; }
                        else { pSize = 1.5; pColor = colLand3; }
                    }
                }
                if (keepPoint) {
                    positions.push(x, y, z);
                    colors.push(pColor.r, pColor.g, pColor.b);
                    sizes.push(pSize);
                }
            }
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: { uMouse: { value: new THREE.Vector3(0, 0, 0) } },
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            transparent: true
        });
        const terrain = new THREE.Points(geometry, shaderMaterial);
        scene.add(terrain);

        // --- 5. 动物 ---
        class TriangleAnimal {
            constructor(name, type, color, startPos) {
                this.name = name;
                this.info = { type: type, desc: "Genetic anomaly detected. High priority target." };
                const geo = new THREE.ConeGeometry(2, 4, 3);
                const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.rotation.x = Math.PI;
                this.mesh.position.copy(startPos);
                this.target = startPos.clone();
                this.speed = 0.08;
                scene.add(this.mesh);
                this.pickTarget();
            }
            pickTarget() {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 80;
                this.target.x = Math.cos(angle) * radius;
                this.target.z = Math.sin(angle) * radius;
            }
            update() {
                const dir = new THREE.Vector3().subVectors(this.target, this.mesh.position);
                if (dir.length() < 1) this.pickTarget();
                dir.normalize();
                this.mesh.position.add(dir.multiplyScalar(this.speed));
                this.mesh.rotation.y += 0.02;
                const y = getElevation(this.mesh.position.x, this.mesh.position.z);
                this.mesh.position.y = y + 8;
            }
        }

        const animals = [
            new TriangleAnimal("TURTLE-X", "Polymer Turtle", 0xff6b6b, new THREE.Vector3(0, 10, 0)),
            new TriangleAnimal("CRAB-9", "Plastic Crab", 0xffaa00, new THREE.Vector3(30, 10, 20)),
            new TriangleAnimal("BIRD-OIL", "Oil Cormorant", 0x4444ff, new THREE.Vector3(-30, 10, -30)),
        ];

        // --- 6. 交互逻辑升级 ---
        let lockedTarget = null;
        const mouseWorld = new THREE.Vector3(); // 鼠标射线位置
        
        document.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(hitPlane);
            if (intersects.length > 0) {
                // 如果没有锁定动物，光标跟随鼠标射线
                if (!lockedTarget) {
                    mouseWorld.copy(intersects[0].point);
                }
                // 更新 Shader 排斥
                shaderMaterial.uniforms.uMouse.value.copy(intersects[0].point);
            }
        });

        // --- 7. 控制器限制 (防止看到地图底部) ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        
        // 关键设置：限制垂直旋转角度
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // 略小于90度，永远无法看穿底面
        controls.minPolarAngle = 0; // 允许完全垂直俯视

        controls.addEventListener('start', () => { controls.autoRotate = false; });

        // --- 8. 动画循环 ---
        const panel = document.getElementById('data-panel');

        function animate() {
            requestAnimationFrame(animate);
            
            let hoverAnimal = null;

            // 1. 动物更新 & 距离检测
            animals.forEach(anim => {
                anim.update();
                
                // 计算鼠标与动物的水平距离
                const dist = new THREE.Vector2(anim.mesh.position.x, anim.mesh.position.z)
                    .distanceTo(new THREE.Vector2(mouseWorld.x, mouseWorld.z));

                if (dist < 8) { 
                    hoverAnimal = anim; // 找到当前悬停的动物
                } 
            });

            // 2. 锁定与光标逻辑 (平滑过渡)
            if (hoverAnimal) {
                lockedTarget = hoverAnimal;
                
                // A. 锁定位置：光标吸附到动物正下方
                const targetX = hoverAnimal.mesh.position.x;
                const targetZ = hoverAnimal.mesh.position.z;
                // 计算地形高度
                const targetY = getElevation(targetX, targetZ);
                
                // 线性插值 (Lerp) 平滑移动光标
                cursorGroup.position.x += (targetX - cursorGroup.position.x) * 0.1;
                cursorGroup.position.z += (targetZ - cursorGroup.position.z) * 0.1;
                cursorGroup.position.y += (targetY - cursorGroup.position.y) * 0.1;

                // B. 放大变色
                cursorGroup.scale.lerp(new THREE.Vector3(2.5, 2.5, 2.5), 0.1);
                hexMaterial.color.set(0xff4444); // 红色警戒

                // C. 显示 UI
                document.getElementById('panel-name').innerText = hoverAnimal.name;
                document.getElementById('panel-desc').innerText = hoverAnimal.info.desc;
                document.getElementById('bar-tox').style.width = "85%";
                document.getElementById('bar-adp').style.width = "72%";
                panel.style.display = 'block';

            } else {
                lockedTarget = null;

                // A. 跟随鼠标：位置基于鼠标射线和地形高度
                const targetY = getElevation(mouseWorld.x, mouseWorld.z);
                
                cursorGroup.position.x += (mouseWorld.x - cursorGroup.position.x) * 0.2;
                cursorGroup.position.z += (mouseWorld.z - cursorGroup.position.z) * 0.2;
                cursorGroup.position.y += (targetY - cursorGroup.position.y) * 0.2;

                // B. 恢复正常大小
                cursorGroup.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                hexMaterial.color.set(0x333333); // 恢复深灰

                // C. 隐藏 UI
                panel.style.display = 'none';
            }

            // 让光标缓慢旋转，增加科技感
            cursorHex.rotation.z += 0.01;

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
